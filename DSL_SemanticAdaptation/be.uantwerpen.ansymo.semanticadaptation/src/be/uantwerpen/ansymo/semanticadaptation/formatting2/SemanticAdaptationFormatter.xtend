/*
 * generated by Xtext 2.11.0
 */
package be.uantwerpen.ansymo.semanticadaptation.formatting2

import be.uantwerpen.ansymo.semanticadaptation.generator.Log
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Adaptation
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SemanticAdaptation
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.util.Strings

class SemanticAdaptationFormatter extends AbstractFormatter2 {
	
	//@Inject extension SemanticAdaptationGrammarAccess

	def dispatch void format(SemanticAdaptation semanticAdaptation, extension IFormattableDocument document) {
		Log.push("Formatting document")
		
		val adaptations = semanticAdaptation.elements.filter(Adaptation)
		if (adaptations.size == 0){
			Log.println("Warning: document has no adaptation declared. This is not supported yet.")
			return
		}
		
		val sa = adaptations.head
		
		Log.println("Adaptation: " + sa)
		sa.format
		
		Log.pop("Formatting document")	
	}
	
	def dispatch void format(Adaptation sa, extension IFormattableDocument document){
		Log.push("Formatting adaptation")
		
		sa.regionFor.keyword('input').prepend[newLine]
		sa.regionFor.keyword('output').prepend[newLine]
		sa.regionFor.keyword('param').prepend[newLine]
		sa.regionFor.keyword('param').prepend[newLine]
		
		if (sa.in !== null){
			sa.in.allRegionsFor.keyword('in').prepend[newLine]
		}
		
		
		/*
		for (inPort : sa.inports){
			Log.push("Formatting inPort " + inPort.name)
			
			inPort.regionFor.feature(SemanticAdaptationPackage.Literals.PORT__TYPE).prepend[newLine]
			
			Log.pop("Formatting inPort " + inPort.name)	
		}
		 */
		
		Log.pop("Formatting adaptation")	
	}
	
}
