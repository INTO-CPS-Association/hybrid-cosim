/*
 * generated by Xtext 2.10.0
 */
package be.uantwerpen.ansymo.semanticadaptation.generator

import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Adaptation
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Port
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SemanticAdaptation
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SemanticAdaptationFactory
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SingleParamDeclaration
import java.io.ByteArrayOutputStream
import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SemanticAdaptationCanonicalGenerator extends AbstractGenerator {
	
	String CANONICAL_EXT = ".BASE.sa"
	String NAME_SUFFIX = "_BASE"
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		println("Generating canonical semantic adaptation for file " + resource.URI.toFileString() + "...")
		
		println("Resource URI information:")
		println("\t resource.URI.lastSegment = " + resource.URI.lastSegment())
		println("\t resource.URI.trimFileExtension = " + resource.URI.trimFileExtension())
		
		println("______________________________File Read______________________________")
		var outputByteArray = new ByteArrayOutputStream()
		resource.save(outputByteArray, null)
		println(outputByteArray.toString())
		outputByteArray.close()
		println("__________________________________________________________________________")
		
		// Create file name for the canonical sa file
		var fileNameWithoutExt = resource.URI.trimFileExtension().lastSegment()
		var canonicalFileName = fileNameWithoutExt + CANONICAL_EXT
		println("canonicalFileName = " + canonicalFileName)
		
		// Create in memory representation of canonical SA file
		var adaptations = resource.allContents.toIterable.filter(SemanticAdaptation).last.elements.filter(Adaptation);
		if (adaptations.size > 1){
			throw new Exception("Only one semantic adaptation is supported per .sa file")
		}
		var adaptation = adaptations.head
		
		println("Checking if file is already a canonical version...")
		if (adaptation.name.indexOf(NAME_SUFFIX) == -1){
			println("It is not.")
			
			adaptation.name = adaptation.name + NAME_SUFFIX
			
			adaptation.canonicalize
						
			outputByteArray = new ByteArrayOutputStream()
			adaptation.eResource.save(outputByteArray,null)
			
			println("______________________________Generated file______________________________")
			println(outputByteArray.toString())
			println("__________________________________________________________________________")
			
			fsa.generateFile(canonicalFileName, outputByteArray.toString())
			println("File " + canonicalFileName + " written.")
			outputByteArray.close()
			
			println("Generating canonical semantic adaptation for file " + resource.URI + "... DONE.")
			
		} else {
			println("It is already a canonical version.")
			println("Nothing to do.")
		}

	}
	
	def canonicalize(Adaptation sa){
		
		// TODO Add input ports
		
		addInParams(sa)
		
	}
	
	def addInParams(Adaptation adaptation) {
		println("Adding input parameters...")
		
		val PARAM_PREFIX = "INIT_"
		
		var inputPort_to_parameterDeclaration_Map = new HashMap<Port, SingleParamDeclaration>(adaptation.inports.size)
		
		for (inputPortDeclaration : adaptation.inports) {
			println("Generating parameter for port " + inputPortDeclaration.name)
			var paramname = PARAM_PREFIX + inputPortDeclaration.name.toUpperCase()
			var paramAlreadyDeclared = false
			for(paramDeclarations : adaptation.params){
				for(paramDeclaration : paramDeclarations.declarations){
					if(paramDeclaration.name == paramname){
						paramAlreadyDeclared = true
					}
				}
			}
			if (paramAlreadyDeclared){
				println("Parameter " + paramname + " already declared for port " + inputPortDeclaration.name)
			} else {
				println("Declaring new parameter " + paramname + " for port " + inputPortDeclaration.name)
				var factory = SemanticAdaptationFactory.eINSTANCE
				if (adaptation.params.size == 0){
					adaptation.params.add(factory.createParamDeclarations())
				}
				var paramDeclaration = factory.createSingleParamDeclaration()
				
				// TODO Continue here after solving problem with ports.
				
				//adaptation.params.head.declarations.add()
			}
		}
		
		println("Adding input parameters... DONE")
	}
	
}
