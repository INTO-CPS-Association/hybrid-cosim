/*
 * generated by Xtext 2.10.0
 */
package be.uantwerpen.ansymo.semanticadaptation.generator

import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Adaptation
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.BoolLiteral
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.BuiltinFunction
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Close
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Connection
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.DeclaredParameter
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Expression
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.InnerFMUDeclarationFull
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.IntLiteral
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.IsSet
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Port
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.RealLiteral
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SemanticAdaptation
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SemanticAdaptationFactory
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SingleParamDeclaration
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.SingleVarDeclaration
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.StringLiteral
import be.uantwerpen.ansymo.semanticadaptation.semanticAdaptation.Variable
import java.io.ByteArrayOutputStream
import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.LinkedList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SemanticAdaptationCanonicalGenerator extends AbstractGenerator {
	
	String CANONICAL_EXT = ".BASE.sa"
	String NAME_SUFFIX = "_BASE"
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		println("Generating canonical semantic adaptation for file " + resource.URI.toFileString() + "...")
		
		println("Resource URI information:")
		println("\t resource.URI.lastSegment = " + resource.URI.lastSegment())
		println("\t resource.URI.trimFileExtension = " + resource.URI.trimFileExtension())
		
		println("______________________________File Read______________________________")
		var outputByteArray = new ByteArrayOutputStream()
		resource.save(outputByteArray, null)
		println(outputByteArray.toString())
		outputByteArray.close()
		println("__________________________________________________________________________")
		
		// Create file name for the canonical sa file
		var fileNameWithoutExt = resource.URI.trimFileExtension().lastSegment()
		var canonicalFileName = fileNameWithoutExt + CANONICAL_EXT
		println("canonicalFileName = " + canonicalFileName)
		
		// Create in memory representation of canonical SA file
		var adaptations = resource.allContents.toIterable.filter(SemanticAdaptation).last.elements.filter(Adaptation);
		if (adaptations.size > 1){
			throw new Exception("Only one semantic adaptation is supported per .sa file")
		}
		var adaptation = adaptations.head
		
		println("Checking if file is already a canonical version...")
		if (adaptation.name.indexOf(NAME_SUFFIX) == -1){
			println("It is not.")
			
			adaptation.name = adaptation.name + NAME_SUFFIX
			
			adaptation.canonicalize
						
			outputByteArray = new ByteArrayOutputStream()
			adaptation.eResource.save(outputByteArray,null)
			
			println("______________________________Generated file______________________________")
			println(outputByteArray.toString())
			println("__________________________________________________________________________")
			
			fsa.generateFile(canonicalFileName, outputByteArray.toString())
			println("File " + canonicalFileName + " written.")
			outputByteArray.close()
			
			println("Generating canonical semantic adaptation for file " + resource.URI + "... DONE.")
			
		} else {
			println("It is already a canonical version.")
			println("Nothing to do.")
		}

	}
	
	def canonicalize(Adaptation sa){
		
		//inferUnits(sa)
		
		
		// Type inference
		genericDeclarationInferenceAlgorithm(sa , 
			[// getField
				element | {
					if (element instanceof SingleParamDeclaration) {
						return element.type
					} else if (element instanceof Port){
						return element.type
					} else if (element instanceof SingleVarDeclaration){
						return element.type
					} else {
						throw new Exception("Unexpected element type: " + element)
					}
				}
			],
			[// setField
				element, value | {
					if (element instanceof SingleParamDeclaration) {
						element.type = value as String
					} else if (element instanceof Port){
						element.type = value as String
					} else if (element instanceof SingleVarDeclaration){
						element.type = value as String
					} else {
						throw new Exception("Unexpected element type: " + element)
					}
				}
			],
			[// inferField
				element | {
					if (element instanceof SingleParamDeclaration) {
						return extractTypeFromExpression(element.expr, element.name)
					} else if (element instanceof Port){
						return getPortType(element)
					} else if (element instanceof SingleVarDeclaration){
						return extractTypeFromExpression(element.expr, element.name)
					} else {
						throw new Exception("Unexpected element type: " + element)
					}
				}
			]
		)
		
		// TODO Add input ports
		
		// Add in params
		addInParams(sa)
		
	}
	
	def genericDeclarationInferenceAlgorithm(Adaptation sa, 
												(EObject)=>Object getField, 
												(EObject, Object)=>void setField,
												(EObject)=>Object inferField
	){
		println("Running generic inference algorithm...")
		
		/*
		 * Dumbest (and simplest) algorithm for this is a fixed point computation:
		 * 1. Look for every var/port declaration
		 * 2. If that var has a XXX already, nothing else to be done.
		 * 3. If that var has no XXX declared, then
		 * 3.1 If var/port has an initial value or connection, then
		 * 3.1.1 If the initial_value/connection has a XXX declared, then var gets that XXX.
		 * 3.1.2 Otherwise, nothing else to be done.
		 * 3.2 If var/port has no initial value or connection then this either is a missing feature, or an error.
		 * 3.3 If something has changed, go to 1. Otherwise, end.
		 * 
		 * An extra set of instructions is there to push the element field information using connections and bindings.
		 */
		var fixedPoint = false
		var unfieldedElementsCounter = 0
		while (! fixedPoint){
			fixedPoint = true
			unfieldedElementsCounter = 0
			
			println("Inferring parameter fields...")
			
			for (paramDeclarations : sa.params) {
				for (paramDeclaration : paramDeclarations.declarations) {
					println("Computing field for param " + paramDeclaration.name)
					if(getField.apply(paramDeclaration) !== null){
						println("Already has been inferred: " + getField.apply(paramDeclaration))
					} else {
						println("Has not been inferred yet.")
						if (tryInferAndAssignField(paramDeclaration, getField, setField, inferField)){
							fixedPoint = false
						} else {
							unfieldedElementsCounter++
						}
					}
				}
			}
			
			if(sa.inner !== null){
				if(sa.inner instanceof InnerFMUDeclarationFull){
					var innerFMUFull = sa.inner as InnerFMUDeclarationFull
					for(fmu : innerFMUFull.fmus){
						println("Inferring port fields of FMU " + fmu.name)
						for (port : EcoreUtil2.getAllContentsOfType(fmu, Port)) {
							if(getField.apply(port) !== null){
								println("Already has a field: " + getField.apply(port))
							} else {
								if (tryInferAndAssignField(port, getField, setField, inferField)){
									fixedPoint = false
								} else {
									unfieldedElementsCounter++
								}
							}
						}
					}
					
					if (innerFMUFull.connection.size > 0){
						println("Inferring port fields using internal scenario bindings.")
						for (binding : innerFMUFull.connection){
							if (getField.apply(binding.src.port) !== null && getField.apply(binding.tgt.port) !== null){
								println("Both ports have fields already.")
							} else {
								var inferredFieldAttempt = inferPortFieldViaConnection(binding, getField, setField, inferField)
								if (inferredFieldAttempt !== null){
									setField.apply(binding, inferredFieldAttempt)
									fixedPoint = false
									unfieldedElementsCounter--
									println("Got new field: " + inferredFieldAttempt)
								} else {
									println("Cannot infer field from binding now.")
								}
							}
						}
					}
				} else {
					throw new Exception("Field inference only supported for InnerFMUDeclarationFull.")
				}
			}
			
			println("Inferring external port fields...")
			
			var externalPorts = new LinkedList(sa.inports)
			externalPorts.addAll(sa.outports)
			
			for (port : externalPorts) {
				if (getField.apply(port) !== null){
					println("Already has a field: " + getField.apply(port))
					if (pushPortField(port, getField, setField, inferField)){
						fixedPoint = false
						unfieldedElementsCounter--
					} 
				} else {
					if (tryInferAndAssignField(port, getField, setField, inferField)){
						fixedPoint = false
					} else {
						unfieldedElementsCounter++
					}
				}
			}
			
			println("Inferring all other declaration fields...")
			
			for (varDeclaration : EcoreUtil2.getAllContentsOfType(sa, SingleVarDeclaration)) {
				println("Computing field for declaration " + varDeclaration.name)
				if(getField.apply(varDeclaration) !== null){
					println("Already has a field: " + getField.apply(varDeclaration))
				} else {
					if (tryInferAndAssignField(varDeclaration, getField, setField, inferField)){
						fixedPoint = false
					} else {
						unfieldedElementsCounter++
					}
				}
			}
			
			println("Ended iteration with unfielded elements remaining: " + unfieldedElementsCounter)
		} // while (! fixedPoint)
		
		if (unfieldedElementsCounter > 0){
			throw new Exception("Could not infer all fields. There are " + unfieldedElementsCounter + " unfielded elements.")
		}
		
		println("Running generic inference algorithm... DONE")
	}
	
	def tryInferAndAssignField(EObject element, 
									(EObject)=>Object getField, 
									(EObject, Object)=>void setField,
									(EObject)=>Object inferField) {
		var inferredFieldAttempt = inferField.apply(element)
		if (inferredFieldAttempt !== null){
			setField.apply(element, inferredFieldAttempt)
			println("Got new field: " + inferredFieldAttempt)
			return true
		} else {
			println("Cannot infer field now.")
			return false
		}
	}
	
	def extractTypeFromExpression(Expression expression, String declarationName){
		if (expression instanceof IntLiteral){
			return "Integer"
		} else if (expression instanceof RealLiteral){
			return "Real"
		} else if (expression instanceof BoolLiteral){
			return "Bool"
		} else if (expression instanceof StringLiteral){
			return "String"
		} else if (expression instanceof Variable){
			var varRef = expression as Variable
			if (varRef.ref instanceof Port){
				var decl = varRef.ref as Port
				if (decl.type !== null){
					return decl.type
				}
			} else if(varRef.ref instanceof SingleParamDeclaration){
				var decl = varRef.ref as SingleParamDeclaration
				if (decl.type !== null){
					return decl.type
				}
			} else if(varRef.ref instanceof SingleVarDeclaration){
				var decl = varRef.ref as SingleVarDeclaration
				if (decl.type !== null){
					return decl.type
				}
			} else if(varRef.ref instanceof DeclaredParameter){
				throw new Exception("Type cannot be inferred for references to DeclaredParameter (for now). Please specify the explicit type of declaration " + declarationName)
			} else {
				throw new Exception("Unexpected kind of Variable expression found.")
			}
		} else if(expression instanceof BuiltinFunction){
			if (expression instanceof IsSet || expression instanceof Close){
				return "Bool"
			} else {
				return "Real"
			}
		} else {
			throw new Exception("Initial value for declaration " + declarationName + " must be literal or var ref for now. Got instead " + expression + ". If you want complex expressions, give it an explicit type.")
		}
		return null
	}
	
	def inferPortFieldViaConnection(Connection binding, 
										(EObject)=>Object getField, 
										(EObject, Object)=>void setField,
										(EObject)=>Object inferField
	){
		var Object resultField = null
		if (getField.apply(binding.src.port) !== null && getField.apply(binding.tgt.port) !== null){
			throw new Exception("Wrong way of using this function. It assumes type is not inferred yet.")
		} else if (getField.apply(binding.src.port) !== null){
			resultField = getField.apply(binding.src.port)
			println("Target port "+ binding.tgt.port.name +" got new type: " + resultField)
		} else if (getField.apply(binding.tgt.port) !== null){
			resultField = getField.apply(binding.tgt.port)
			println("Target port "+ binding.src.port.name +" got new type: " + resultField)
		}
		
		return resultField
	}
	
	def pushPortField(Port port, 
							(EObject)=>Object getField, 
							(EObject, Object)=>void setField,
							(EObject)=>Object inferField){
		var fieldInferred = false
		println("Pushing field of port " + port.name + " to its bindings.")
		
		if(getField.apply(port) === null){
			println("Has no field to be pushed.")
			// TODO Throw exception wrong usage
		} else {
			println("Pushing field: " + getField.apply(port))
			if(port.sourcedependency !== null){
				println("Has a source dependency: " + port.sourcedependency.port.name)
				if(getField.apply(port.sourcedependency.port) === null){
					setField.apply(port.sourcedependency.port, getField.apply(port))
					println("Port " + port.sourcedependency.port.name + " got new type: " + getField.apply(port.sourcedependency.port))
					fieldInferred = true
				} else {
					println("Source port already has field.")
				}
			} else {
				println("Has no source dependency.")
			}
			
			if (port.targetdependency !== null) {
				println("Has a target dependency: " + port.targetdependency.port.name)
				if(getField.apply(port.targetdependency.port) === null){
					println("Dependency has no field yet.")
					setField.apply(port.targetdependency.port, getField.apply(port))
					println("Port " + port.targetdependency.port.name + " got new type: " + getField.apply(port.targetdependency.port))
					fieldInferred = true
				} else {
					println("Target port already has field.")
				}
			} else {
				println("Has no target dependency.")
			}
		}
		
		return fieldInferred
	}
	
	def getPortType(Port port){
		var typeInferred = false
		
		println("Computing type for port " + port.name)
		
		var String returnType = null
		
		if(port.type !== null){
			throw new Exception("Wrong way of using this function. It assumes type is not inferred yet.")
		} else {
			println("Has no type.")
			
			println("Attempting to infer type from units.")
			if (port.unity !== null){
				returnType = "Real"
				println("Got new type: " + returnType)
				typeInferred = true
			} else {
				println("Attempting to infer type from bindings.")

				if(port.sourcedependency !== null){
					println("Has a source dependency: " + port.sourcedependency.port.name)
					if(port.sourcedependency.port.type === null){
						println("Dependency has no type yet.")
					} else {
						returnType = port.sourcedependency.port.type
						println("Got new type: " + returnType)
						typeInferred = true
					}
				} else {
					println("Has no source dependency.")
				}
				
				if (port.targetdependency !== null && !typeInferred) {
					println("Has a target dependency: " + port.targetdependency.owner.name + "." + port.targetdependency.port.name)
					if(port.targetdependency.port.type === null){
						//println("Port object: " + port.targetdependency.port)
						println("Dependency has no type yet.")
					} else {
						returnType = port.targetdependency.port.type
						println("Got new type: " + port.type)
						typeInferred = true
					}
				} else {
					println("Has no target dependency, or type has already been inferred from source dependency.")
				}
			}
		}
		
		return returnType
	}
	
	def addInParams(Adaptation adaptation) {
		println("Adding input parameters...")
		
		val PARAM_PREFIX = "INIT_"
		
		var inputPort_to_parameterDeclaration_Map = new HashMap<Port, SingleParamDeclaration>(adaptation.inports.size)
		
		for (inputPortDeclaration : adaptation.inports) {
			println("Generating parameter for port " + inputPortDeclaration.name)
			var paramname = PARAM_PREFIX + inputPortDeclaration.name.toUpperCase()
			var paramAlreadyDeclared = false
			for(paramDeclarations : adaptation.params){
				for(paramDeclaration : paramDeclarations.declarations){
					if(paramDeclaration.name == paramname){
						paramAlreadyDeclared = true
					}
				}
			}
			if (paramAlreadyDeclared){
				println("Parameter " + paramname + " already declared for port " + inputPortDeclaration.name)
			} else {
				println("Declaring new parameter " + paramname + " for port " + inputPortDeclaration.name)
				var factory = SemanticAdaptationFactory.eINSTANCE
				if (adaptation.params.size == 0){
					adaptation.params.add(factory.createParamDeclarations())
				}
				var paramDeclaration = factory.createSingleParamDeclaration()
				
				// TODO Continue here after solving problem with ports.
				
				//adaptation.params.head.declarations.add()
			}
		}
		
		println("Adding input parameters... DONE")
	}
	
}
