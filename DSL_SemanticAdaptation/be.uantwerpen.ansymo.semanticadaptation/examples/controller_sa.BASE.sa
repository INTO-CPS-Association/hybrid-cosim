import PowerWindowModel

module Controller_SA

semantic adaptation power_sa

for fmu controller

input ports armature_current, passenger_up, passenger_down, passenger_stop, driver_up, driver_down, driver_stop;

param REL_TOL = 0.0001;
param ABS_TOL = 1e-8;
param CROSSING = 5;
param init_armature_current = CROSSING;
param init_up = 0;
param init_down = 0;

in var previous_arm_current := init_armature_current;
in var stored_displacement := init_displacement;
in var stored_speed := init_speed;
in var next_time_step := -1;
in var step_size;
in var aux_obj_detected;

in rules {
	next_time_step < 0 -> { 
		next_time_step := get_next_time_step(controller) + t; 
		/*
		The get_next_time_step(controller) function is equivalent to the following snippet:
		transaction(controller);
		internal_transition := do_step(controller, t, MAX);
		next_time_step := t + internal_transition;
		rollback(controller);
		*/
	} --> { };
	
	true -> {
		aux_obj_detected := false;
		step_size := H;
		if ((not is_close(stored_armature_current, CROSSING, REL_TOL, ABS_TOL) and stored_armature_current < CROSSING)
					and (not is_close(armature_current, CROSSING, REL_TOL, ABS_TOL) and armature_current > CROSSING)) { // crossing, but not within tolerance
			var negative_value := stored_armature_current - CROSSING;
			var positive_value := armature_current - CROSSING;
			step_size := (H * (- negative_value)) / (positive_value - negative_value);
		} else {
			if (not (not is_close(stored_armature_current, CROSSING, REL_TOL, ABS_TOL) and stored_armature_current > CROSSING)
						and is_close(armature_current, CROSSING, REL_TOL, ABS_TOL)) { // crossing within tolerance found
				aux_obj_detected := true;
			}
		}
	} --> {
		obj_detected := aux_obj_detected; // Sets this input to the FMU 
	};
}

control rules {
	if (obj_detected == true or t >= next_time_step) {
		var aux_h = do_step(controller, t-e, e); // do a step, then decide next internal transition
		assert aux_h == e; // this must always be the case, otherwise it is better not to use the timed transition adaptation.
		internal_transition := -1; // next time the setValues is called, the internal transition will be set again.
	}
	if is_close(step_size, H, REL_TOL, ABS_TOL) {
		// Step accepted, so store the known input.
		// We cannot store the armature current at the in rules because we may not accept the step and because they may be called multiple times. If that happens, we want to still have the old value of armature current, to compare it with the new one.
		stored_armature_current := armature_current;
	}
	return step_size; // the step size is calculated in the in_rules.
}

out var stored_up := init_up;
out var stored_down := init_down;

out rules {
	true -> {
		/*
		Previously, there was this intruction here:
		internal_transition := get_next_time_step(controller) + t
		
		However, it cannot be here, since there is no guarantee in the control rules block, that the doStep of the controller will be called.
		*/
	} --> {};
	
	/*
	What does "otherwise var" mean?
	Suppose I have the following rules:
		var1 == true and var2 == false -> ...
		otherwise var1 -> ...
	*/
	up == true -> { up := 1; } --> { };
	otherwise up -> { } --> { }; 
	down == true -> { down := 1; } --> { };
	otherwise down -> { } --> { };
	stop == true -> { up := 0; down := 0; } --> { };
	otherwise stop -> { } --> { };
	true -> { up := stored_up; stored_up := up; } --> { };
	true -> { down := stored_down; stored_down := down; } --> { }; 
}