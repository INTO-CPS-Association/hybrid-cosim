module Lazy_SA

semantic adaptation reactive moore LazySA lazy_sa
at "./path/to/LazySA.fmu"

	for inner fmu Controller controller
	at "./path/to/Controller.fmu"
	with input ports obj_detected, passenger_up, passenger_down, passenger_stop, driver_up, driver_down, driver_stop
	with output ports up, down, stop

input ports obj_detected -> controller.obj_detected

output ports up, down, stop

param 	INIT_UP := 0.0,
		INIT_DOWN := 0.0,
		INIT_STOP := 0.0;

control var	tn := -1.0,
			tl := -1.0,
			refresh_outputs := true;

control rules {
	if (tl < 0.0){
		tl := t;
	}
	
	refresh_outputs := false;
	
	var step_size := min(H, tn - t); 
	if (lazy_sa.obj_detected or (t+H) >= tn){
		refresh_outputs := true; 
		var step_to_be_done := (t+H-tl);
		var step_done := do_step(controller, t, step_to_be_done); 
		tn := tl + step_done + get_next_time_step(controller); 
		step_size := tl + step_done - t; 
		tl := tl + step_done; 
	}
	
	return step_size;
}

out var	stored_up := INIT_UP,
		stored_down := INIT_DOWN,
		stored_stop := INIT_STOP;
out rules{
	 true -> {
		if (refresh_outputs){
			stored_up := controller.up;
			stored_down := controller.down;
			stored_stop := controller.stop;
		}
	} --> {
		lazy_sa.up := stored_up;
		lazy_sa.down := stored_down;
		lazy_sa.stop := stored_stop;
	};
}
