module Lazy_SA

semantic adaptation reactive moore LazySA lazy_sa
at "./path/to/LazySA.fmu"

	for inner fmu Controller controller
	at "./path/to/Controller.fmu"
	with input ports obj_detected, passenger_up, passenger_down, passenger_stop, driver_up, driver_down, driver_stop
	with output ports up, down, stop

/*
 * We only need to declare one input port: the one we are interested in.
 * The others (both input and output ports) are bound by assumption.
 */
input ports obj_detected -> controller.obj_detected

control var	tn := -1.0,
			tl := -1.0;

control rules {
	// This initialisation covers simulations that start at a non-zero time.
	if (tl < 0.0){
		tl := t;
	}
	
	var step_size := min(H, tn - t); // In case tn < t, this ensures that the controller will be run at the right time.
	// Note that the expression lazy_sa.obj_detected gets replaced by the corresponding storage var in the canonical version.
	if (lazy_sa.obj_detected or (t+H) >= tn){
		var step_to_be_done := (t+H-tl);
		var step_done := do_step(controller, t, step_to_be_done); // calls the mapIn function that will take care of forwarding the values of the input ports to the internal FMU.
		// We calculate these as if step_done == step_to_be_done. If that is not the case, a rollback will be done anyway.
		tn := tl + step_done + get_next_time_step(controller); // calculates the next time step that is tolerated by the controller.
		// This is the actual step size taken, from the outside world:
		step_size := tl + step_done - t; // assert step_size <= H
		tl := tl + step_done; // assert tl == t+H
	}
	
	return step_size;
}

