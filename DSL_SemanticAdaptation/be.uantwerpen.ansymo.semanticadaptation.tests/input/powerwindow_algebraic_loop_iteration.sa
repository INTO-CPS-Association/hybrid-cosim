import PowerWindowModel
import Controller_SA

// this one could be joined with the one below, if we assume certain priorities in executing the rules
semantic adaptation WindowSA window_sa
at "./path/to/WindowSA.fmu"
for fmu window
out rules {
	reaction_torque := -reaction_torque;
}

// algebraic loop
semantic adaptation PowerWindowObstacleSA power_window_obstacle_sa
at "./path/to/PowerWindowObstacleSA.fmu"
for fmu power, window_sa, obstacle
input ports up, down // optional, can be figured out from model
output ports armature_current // optional, can be figured out from model
successive substitution starts at reaction_torque and height with absolute tolerance = 1e-8 and relative tolerance = 0.0001

