import PowerWindowModel

semantic adaptation window_sa
for fmu window
out rules {
	true -> { } --> { reaction_torque := -reaction_torque; };
}

semantic adaptation window_obstacle_sa_loop
for fmu window_sa, obstacle
// just for the sake of declaring this, look at algebraic loop iteration

semantic adaptation window_obstacle_sa_multirate //with master // multi-rate for window and object
for fmu window_obstacle_sa_loop
input ports motor_speed
output ports reaction_torque
param init_motor_speed = 0;
control {
	var h := H/10;
	var proposed_h := H;
	for (var iter in 0 .. 10) {
		var returned_h := do_step(window_obstacle_sa_loop, h);
		if (returned_h != h) { // for backtracking
			 proposed_h := iter*h + returned_h;
		}
	}
	return proposed_h;
}
in var stored_motor_speed := init_motor_speed;
in var linear_increment;
in rules {
	true -> {
		linear_increment := (motor_speed - stored_motor_speed) / 10;
		stored_motor_speed := motor_speed;
	} --> {
		motor_speed := motor_speed + linear_increment;
	};
}